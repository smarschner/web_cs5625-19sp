<script type="text/javascript" async
        src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/MathJax.js?config=TeX-MML-AM_CHTML">
</script>

<p><strong>Due: Thursday Mar 19 2019 (11:59pm).</strong> Work on your own or in groups of 2, as you prefer.</p>

<h2>Written Task</h2>

<h4>A. </h4>
<p> 1). A quaternion $q = q_0 + q_1 \mathbf{i} +q_2 \mathbf{j} + q_3 \mathbf{k} $ can also be written as $q = q_0 + \bf{q}$, where the scalar $q_0$ denotes real part and the vector $\mathbf{q}$ denotes the imaginary part. When $q_0=0$, we call it a pure quaternion. The multiplication of two pure quaternaions follows the rule:
    $$\mathbf{v}\mathbf{w} = -\mathbf{v}\cdot \mathbf{w}+ \mathbf{v}\times\mathbf{w}$$
    Show the above rule by writing out each quaternion explicitly using 1, $\mathbf{i}$, $\mathbf{j}$, $\mathbf{k}$ units.</p>

<p>2). Show the following identity:
    $$\mathbf{v}\mathbf{w}\mathbf{v} = \mathbf{w}(\mathbf{v}\cdot\mathbf{v}) - 2\mathbf{v}(\mathbf{v}\cdot\mathbf{w})$$
</p>

<h4>B. </h4>
<p>A quaternion $q = q_0 + \mathbf{q}$ is a unit quaternion when its norm is one, i.e. 
$$||q||^2 = q_0^2 + ||\mathbf{q}||^2 = 1$$ 
Given a unit quaternion $q = q_0 + \mathbf{q}$, there exists a unique $\psi\in [0, \pi]$ such that $\cos(\psi) = q_0$ and $\sin(\psi) = ||\mathbf{q}||$. So a unit quaternion can be written using this angle $\psi$ and a unit vector $\mathbf{u} = \frac{\mathbf{q}}{||\mathbf{q}||}$:
$$q = \cos(\psi) + \sin(\psi)\mathbf{u}$$
Let $q^*$ denote the conjugate of $q$. Define an operator on a 3D vector $\mathbf{v}$:
$$L_q(\mathbf{v}) = q\mathbf{v}q^*$$
For a unit quaternion $q = \cos(\psi) + \sin(\psi)\mathbf{u}$ and any 3D vector $v$, show that the operator $L_q(\mathbf{v})$ acts as a rotation of the vector $\mathbf{v}$ around the axis $\mathbf{u}$ with angle $2\psi$.
<p>Hints:</p>
    1. We've proven in class the Rodrigues' rotation formula. The rotation of a 3D vector $\mathbf{v}$ with angle $\theta$ around an axis defined by the unit vector $\mathbf{u}$ results in the rotated vector $\mathbf{v}_{rot}$:
    $$\mathbf{v}_{rot} = \mathbf{v}\cos(\theta) + (\mathbf{u}\times\mathbf{v})\sin(\theta) + \mathbf{u}(\mathbf{u}\cdot \mathbf{v})(1-\cos(\theta))$$
<p> 2. The identities from part A might be useful.</p>
3. Recall double angle trigonometric formulas:
    $$\cos(2\theta) = \cos^2(\theta) - \sin^2(\theta) = 1-2\sin^2(\theta)$$
    $$\sin(2\theta) = 2\sin(\theta)\cos(\theta)$$
</p>

<h2>Programming part</h2>

      <h2 id="overview">Overview</h2>

      <p>In this programming assignment, you will implement:
        <ol>
          <li>blend shapes for facial expressions, and</li>
          <li>linear blend skinning for articulated character animations.</li>
        </ol>
      </p>
    
      <h2 id="task7">Task 1: Blend shapes</h2>

      <p>Run the <a href="../student/src/pa2/PA2_BlendShapes.java">pa2.PA2_BlendShapes</a> class, and you will see that the program allows you to change between three characters:      
      </p>

      <table class="table table-bordered">
        <tr>
          <td align="center" valign="center"><a href="images/pa2/kaito.png"><img src="images/pa2/kaito.png" width="200" /></a></td>
          <td align="center" valign="center"><a href="images/pa2/miku.png"><img src="images/pa2/miku.png" width="200" /></a></td>
          <td align="center" valign="center"><a href="images/pa2/uta.png"><img src="images/pa2/uta.png" width="200" /></a></td>
        </tr>
        <tr>
          <td align="center">KAITO</td>
          <td align="center">Hatsune Miku</td>
          <td align="center">Utane Uta</td>
        </tr>
      </table>

      <p>Each charcter has a set of blend shapes or, as we shall call it in this assignment, "morphs," associated with it.  A morph in this assigment modifies some facial features of the character, making him/her wink, for example.  A specific morph can be selected by the combo box next in the bottom row.  Each morph also has an associated "weight," which is a floating point number from 0 to 1.  You can set this value using the spinner and the slider in the bottom row.</p>

      <p>The basics of blend shapes were discussed in the animation <a href="http://www.cs.cornell.edu/Courses/cs5625/2014fa/lectures/07mesh-animation.pdf">lecture</a>.  The idea is that each vertex comes with a 3D position for each of $N$ blend shapes, and the animation is controlled by per-frame weights $w_j$ for each blend shape, which sum to $1$.  If  $\mathbf{p}_{ij}$ is the position of vertex $i$ in blend shape $j$, and $w_j$ is the weight of blend shape $j$ in the current frame, then the position of vertex $i$ is $$\mathbf{p}_i' = \sum_j w_j\mathbf{p}_{ij}.$$</p>

      <p>Because the blend shapes are the same over most of the character, in this assignment the blend shapes are stored as <i>displacements</i> from a neutral pose; that is
        $$\mathbf{p}_{ij} = \mathbf{p}_i + \mathbf{d}_{ij}$$
      so that the blended position is 
      $$\mathbf{p}_i' = \mathbf{p}_i + \sum_j w_j\mathbf{d}_{ij}.$$ 
      Since the neutral shape has all displacements zero, it can be left out, and the weights no longer have to sum to $1$.</p>

      <p>These displacements are zero for most vertices in each blend shape, so for each blend shape $j$ the intput file contains a list of the indices $i$ that have nonzero displacements, with values of $\mathbf{d}_{ij}$ just for those vertices.  The data is stored in the scene inpur files like <tt>???</tt>, and is read by our asset importing library along with the mesh geometry. To keep the vertex processing phase fast, from this basic data we  construct a list of the blend shapes that affect a particular vertex, so that we can process only those displacements in the vertex shader.  The code to read these files and store the data in textures is provided.  All this leads to a great decrease in storage and computation, at the cost of somewhat more complex indexing.  </p>      

      <p>For this task, edit:
        <ul>
          <li><a href="../student/src/shaders/forward/skeletal_mesh.vert">student/src/shaders/forward/skeletal_mesh.vert</a></li>
        </ul>
        so that the shader implements morphing of vertices.
      </p>

      <p>Information about morphs come to the shader in pieces of three data structures.
        <ul>
          <li>The first is the <tt>vert_morphWeights</tt> uniform array.  This is an array of length equal to the number of morphs in which the $j$th entry contains the weight of the $j$th morph.  You can use the <tt>getMorphWeight</tt> function to fetch the weight of the morph with a given index (which starts from 0).</li>  (srm: might not need this)
          <li>The second is the <tt>vert_morphDisplacements</tt> texture.  You can think of this as an array containing displcements to individual vertices from all the morphs, sorted by the vertex index.  (It will become apparent soon why we sort it this way.)  You can recover the $i$th entry of the array using the <tt>getMorphDisplacementInfo(int i)</tt> function.  The function returns a <tt>vec4</tt> whose x-, y-, and z-components denote the displacement being applied to the vertex position.  The w-component stores the index of the morph having this displacement.</li>
          <li>The third is the vertex data.  (srm: need to update) 
        </ul>
      </p>

      <p>(srm: need to update this) Let $n$ denote the value of <tt>vert_morphCount</tt>.  To compute a morphed vertex position, write a loop that starts fetching the <tt>vert_morphDisplacements</tt> array at indices <tt>vert_morphStart</tt>, <tt>vert_morphStart</tt>+1, <tt>vert_morphStart</tt>+2, $\dotsc$, <tt>vert_morphStart</tt>+$n$-1.  Each of these texture fetching will give you information about the largest displacement that you can apply to the vertex and the index of the associated morph.  Now, with the index of the morph at hand, you can find the weight of the morph from the <tt>vert_morphWeights</tt> texture.  Once you know the weight, scale the displacement by the it and add the resulting weighted displacement to the vertex position.  (For morphing, you only change the vertex position and do not have to care about the normal, the tangent, or the bitangent.)</p>

      <p>A correct implementation of the shader should yield the following images</p>

      <table class="table table-bordered">
        <tr>
          <td align="center">Morph</td>
          <td align="center">KAITO</td>
          <td align="center">Hatsune Miku</td>
          <td align="center">Utane Uta</td>
        </tr>
        <tr>
          <td align="center">Eye: Wink (both)</td>
          <td align="center"><a href="images/pa2/kaito-wink.png"><img src="images/pa2/kaito-wink.png" width="200"></a></td>
          <td align="center"><a href="images/pa2/miku-wink.png"><img src="images/pa2/miku-wink.png" width="200"></a></td>
          <td align="center"><a href="images/pa2/uta-wink.png"><img src="images/pa2/uta-wink.png" width="200"></a></td>
        </tr>
        <tr>
          <td align="center">Mouth: a</td>
          <td align="center"><a href="images/pa2/kaito-a.png"><img src="images/pa2/kaito-a.png" width="200"></a></td>
          <td align="center"><a href="images/pa2/miku-a.png"><img src="images/pa2/miku-a.png" width="200"></a></td>
          <td align="center"><a href="images/pa2/uta-a.png"><img src="images/pa2/uta-a.png" width="200"></a></td>
        </tr>
        <tr>
          <td align="center">Eye: Small iris</td>
          <td align="center"><a href="images/pa2/kaito-small-eye.png"><img src="images/pa2/kaito-small-eye.png" width="200"></a></td>
          <td align="center"><a href="images/pa2/miku-small-eye.png"><img src="images/pa2/miku-small-eye.png" width="200"></a></td>
          <td align="center"><a href="images/pa2/uta-small-eye.png"><img src="images/pa2/uta-small-eye.png" width="200"></a></td>
        </tr>
      </table>


      <h2 id="task8">Task 2: Linear blend skinning</h2>

      <p>The second part of a standard character animation system is linear blend skinning, a technique that allows vertices of a mesh to deform according to an underlying skeleton. Linear blend skinning is discussed in the same lecture referenced above.  The basic idea is that the pose of an animated character is specified by using per-frame linear transformations (usually rigid) for each of a set of <i>bones</i> in the skeleton, and the deformed positions of the mesh (the "skin") are computed by applying a combination of the bone transformations to the neutral vertex position.  The influence of bone $j$ on vertex $i$ is given by a fixed (not per-frame) weight $w_{ij}$, so the deformed position is:
        $$\mathbf{p}_i' = \sum_j w_{ij} M_j \mathbf{p}_i$$
      where $\mathbf{p}_i$ is the undeformed vertex position. Since each vertex is normally influenced by only a few bones, in this assignment we store the weights for a vertex $i$ by keeping a list of the bone indices $j$ for which the weights $w_{ij}$ are nonzero, togther with the values of those weights.  Each vertex is only allowed to be influenced by up to four bones, so we store exactly four indices for each vertex, using the value $-1$ to indicate an unused index.

      <p>With the math set up this way, there are several pieces of data required to animate a mesh.  First, the animation rig consists of a skeleton and corresponding weights.  The weights are stored in vertex attributes on the mesh: one integer 4-vector containing the active bone indices for the vertex an one floating-point 4-vector giving the weights.  The skeleton is associated with a hierarchy of scene nodes corresponding to the bones, together with a list of the bones that establishes their order for referring to them by indices.  Finally, the skeleton's scene nodes are animated using keyframed transformations; these transformations define the bone transformations for each fram.  See for example the single-frame animation in <tt>???</tt>.  (srm: seems good to provide one or two test inputs that have no motion, for testing, if it is easy to do so)

      <p>For this task, you'll need to:
        <ul>
          <li>edit <a href="../student/src/shaders/forward/skeletal_mesh.vert">student/src/shaders/forward/skeletal_mesh.vert</a>, and</li>
          <li>write the C++ code that supplies the transformation data to this shader.</li>
        </ul>
      </p>

      <p>The framework as distributed loads the rigging and animation data into several classes where you can use it to compute the per-frame bone transformations required for the vertex shader.
      <ul>
      	<li>The <tt>Skeleton</tt> class (defined in <tt>Common/Scene.hpp</tt>) contains a list of <tt>Bone</tt> objects, in order of bone index, and a pointer to the root node of the skeleton's hierarchy in the scene.</li>
      	<li><tt>Bone</tt> objects are <tt>SceneObject</tt>s, so they are associated with nodes in the scene.  Each bone stores (the inverse of) it <i>bind pose matrix</i>, which is the transformation of that node relative to the skeleton's root when the skeleton is undeformed (that is, it's in the pose that matches the shape of the undeformed mesh).</li>
      	<li>The scene can contain an <tt>Animation</tt>, which stores a <tt>NodeAnim</tt> object for each animated node.</li>
      	<li>A <tt>NodeAnim</tt> object contains collections of keyframes for the object's rotation, translation, and scale.
      </ul>

      [Eston -- I'm thinking maybe leaving in the interpolation code is fine, since writing it is the same task as in 4620 and describing exactly what the meaning of the keyframe data is a little complicated.]

      <p>With all these objects available, the computation of the bone transformations for a given frame goes like this:
      	<ol>
      		<li>For each bone in the skeleton, get the transformation from its node to the root of the skeleton at time $t$.</li>
      		<li>Multiply this transformation by the inverse of the bind pose matrix to obtain the bone transformation (the transformation that carries the bind-pose bone to the current-frame bone).</li>
      		<li>Put this matrix in the corresponding entry of the <tt>vert_boneXforms</tt> uniform array (see below for how to do this without making a lot of OpenGL calls).</li>
      	</ol>
	Finally, the vertex shader will use these matrices, along with the weights stored in the mesh attributes, in the equation above to compute deformed vertex positions.

      <p>We now discuss further the computation of the matrices for linear blend skinning.  Let:
        <ul>
          <li>$T_i^{\mathrm{R}}$ denote the 4x4 translation matrix associated with the displacement of Bone $i$ to its parent in rest position.</li>
          <li>$T_i^{\mathrm{P}}$ denote the 4x4 translation matrix associated with the displacement stored in the $i$th element of <tt>boneDisplacements</tt>.</li>
          <li>$R_i^{\mathrm{P}}$ denote the 4x4 rotation matrix associated with the quaternion stored in the $i$th element of <tt>boneRotations</tt>.</li>
        </ul>
      Now, let us say that we are interested in Bone $i_k$, which is a child of Bone $i_{k-1}$, which in turn is a child of Bone $i_{k-2}$, and so on until we reach bone $i_0$ which does not have a parent.  The matrix for linear blend skinning can be computed in two steps:
        <ol>
          <li>First, compute the 4x4 transformation matrix associated with the translation from the origin to the world position of Bone $i_k$ in <i>rest position</i>.  This matrix is given by:
            $$M^{\mathrm{R}}_{i_k} = T^{\mathrm{R}}_{i_0} T^{\mathrm{R}}_{i_1} T^{\mathrm{R}}_{i_2} \dotsm T^{\mathrm{R}}_{i_{k-1}} T^{\mathrm{R}}_{i_k}.$$ 
          </li>
          <li>Second, compute the 4x4 transformation matrix associated with going from the origin to the world position of Bone $i_k$ according to the <i>pose</i>.  This matrix is given by:
            $$ M^{\mathrm{P}}_{i_k} = ( T^{\mathrm{R}}_{i_0} T^{\mathrm{P}}_{i_0} R^{\mathrm{P}}_{i_0} ) ( T^{\mathrm{R}}_{i_1} T^{\mathrm{P}}_{i_1} R^{\mathrm{P}}_{i_1} ) \dotsm ( T^{\mathrm{R}}_{i_{k-1}} T_{i_{k-1}}^{\mathrm{P}} R_{i_{k-1}}^{\mathrm{P}} ) ( T^{\mathrm{R}}_{i_k} T_{i_k}^{\mathrm{P}} R_{i_k}^{\mathrm{P}} ). $$
          </li>
          <li>The bone matrix for linear blend skinning is then given by:
            $$ M_{i_k} = M^{\mathrm{P}}_{i_k} ( M^{\mathrm{R}}_{i_k} )^{-1}. $$
          </li>
        </ol>
      </p>

      <p>To perform linear blend skinning, we first morph the vertex according to the blend shapes as was done in the last task.  Let us denote the morphed vertex position by $\mathbf{p}$.  The vertex can be influenced by a number of bones, and each of this bone has different amount of influence on the vertex, indicated by the bone's <i>weight</i>.  The indices of the bones that influence the vertex is stored in the <tt>vert_boneIndices</tt> attributes, a <tt>vec4</tt>, meaning that there can be at most four bones that can influence the vertex.  You can retrieve the index of the $j$th bone with the expression <tt>vert_boneIndices[j]</tt> where $j$ ranges from 0 to 3.  Some of these indices may be -1, indicating that this is not a valid bone and should be ignored.  The weights of the bones are stored in the attribute <tt>vert_boneWeights</tt>, and the weight of the $j$th bone can be retrieved by the expression <tt>vert_boneWeights[j]</tt>.  Now, suppose that the indices of the bones are $j_0$, $j_1$, $j_2$, and $j_3$, and the associated weights are $w_{j_0}$, $w_{j_1}$, $w_{j_2}$, and $w_{j_3}$.  Then, the linear blended vertex position is given by:
        $$ \mbox{blended vertex position} = w_{j_0} M_{j_0} p + w_{j_1} M_{j_1} p + w_{j_2} M_{j_2} p + w_{j_3} M_{j_3} p.$$
      Now, you also have to compute the blended tangent, bitangent, and normal.  We suggest that you compute the tangent and bitangent using the formula similar to the above.  Then, you can compute the normal by computing the cross product between the two vectors.</p>

      <p>Lastly, note that the positions and tangent frame you computed in the last paragraph are in <i>object space</i>.  You have to transform them with the appropriate matrices to pass them to the fragment shaders and the rasterization unit.  However, the code to do this has already been provided for you in the shader.</p>

      <p>You can test the full implementation of the character animation system by running the <a href="../student/src/pa2/PA2_Animations.java">pa2.PA2_Animations</a> class.  Here, you still have the option of selecting among the three characters, but you can also subject them to 5 poses/animations.  A correct implementation of the system should produce the following images:
      </p>      

      <table class="table table-bordered">
        <tr>
          <td align="center">Animation/Pose</td>
          <td align="center">KAITO</td>
          <td align="center">Hatsune Miku</td>
          <td align="center">Utane Uta</td>
        </tr>
        <tr>
          <td align="center">Stand 1</td>
          <td align="center"><a href="images/pa2/kaito-stand1.png"><img src="images/pa2/kaito-stand1.png" width="200" /></a></td>          
          <td align="center"><a href="images/pa2/miku-stand1.png"><img src="images/pa2/miku-stand1.png" width="200" /></a></td>          
          <td align="center"><a href="images/pa2/uta-stand1.png"><img src="images/pa2/uta-stand1.png" width="200" /></a></td>          
        </tr>
        <tr>
          <td align="center">Stand 2</td>
          <td align="center"><a href="images/pa2/kaito-stand2.png"><img src="images/pa2/kaito-stand2.png" width="200" /></a></td>          
          <td align="center"><a href="images/pa2/miku-stand2.png"><img src="images/pa2/miku-stand2.png" width="200" /></a></td>          
          <td align="center"><a href="images/pa2/uta-stand2.png"><img src="images/pa2/uta-stand2.png" width="200" /></a></td>          
        </tr>
        <tr>
          <td align="center">Stand 3</td>
          <td align="center"><a href="images/pa2/kaito-stand3.png"><img src="images/pa2/kaito-stand3.png" width="200" /></a></td>          
          <td align="center"><a href="images/pa2/miku-stand3.png"><img src="images/pa2/miku-stand3.png" width="200" /></a></td>          
          <td align="center"><a href="images/pa2/uta-stand3.png"><img src="images/pa2/uta-stand3.png" width="200" /></a></td>          
        </tr>
        <tr>
          <td align="center">Suki Yuki Maji Magic! (frame 3,000)</td>
          <td align="center"><a href="images/pa2/kaito-suki.png"><img src="images/pa2/kaito-suki.png" width="200" /></a></td>          
          <td align="center"><a href="images/pa2/miku-suki.png"><img src="images/pa2/miku-suki.png" width="200" /></a></td>          
          <td align="center"><a href="images/pa2/uta-suki.png"><img src="images/pa2/uta-suki.png" width="200" /></a></td>          
        </tr>
        <tr>
          <td align="center">Neko Mimi Switch (frame 3,000)</td>
          <td align="center"><a href="images/pa2/kaito-neko.png"><img src="images/pa2/kaito-neko.png" width="200" /></a></td>          
          <td align="center"><a href="images/pa2/miku-neko.png"><img src="images/pa2/miku-neko.png" width="200" /></a></td>          
          <td align="center"><a href="images/pa2/uta-neko.png"><img src="images/pa2/uta-neko.png" width="200" /></a></td>          
        </tr>
      </table>

      <p>For your reference, see the following Youtube videos for the full <a href="https://www.youtube.com/watch?v=Yt7AoSS6tM4">Suki Yuki Maji Magic!</a> and <a href="https://www.youtube.com/watch?v=Dz-fGXYPGzg">Neko Mimi Switch</a> motions.</p>

      <p>Lastly, run <a href="../student/src/pa2/PA2_DanceScene.java">pa2.PA2_DanceScene</a> to see two characters dance as a duet.  This scene uses the Blinn-Phong material, so make sure that you edit <a href="../student/src/pa2/ForwardRenderer.java">pa2.ForwardRenderer</a> so that it can use the material as well.</p> 

      <table class="table table-bordered">
          <tr>
              <td align="center"><a href="images/pa2/dance-0000.png"><img width="200" src="images/pa2/dance-0000.png" /></a></td>
              <td align="center"><a href="images/pa2/dance-2000.png"><img width="200" src="images/pa2/dance-2000.png" /></a></td>
              <td align="center"><a href="images/pa2/dance-3104.png"><img width="200" src="images/pa2/dance-3104.png" /></a></td>
              <td align="center"><a href="images/pa2/dance-4862.png"><img width="200" src="images/pa2/dance-4862.png" /></a></td>
          </tr>
      </table>

      <h2 id="credits">Credits and Copyrights</h2>

 	<p>TODO remark on origins of the animation data we are using</p>

      <p>We are grateful of all the creators for their efforts and setting permissive conditions for reuse of their works.</p>
